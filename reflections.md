Reflections
===========

<!--
This file generated by the build script at ./Build.hs from the files in
./reflections.  If you want to edit this, edit those instead!
-->

*[2016][]* / *[2017][]* / *[2018][]* / *[2019][]* / *2020*

[2016]: https://github.com/mstksg/advent-of-code-2016/blob/master/reflections.md
[2017]: https://github.com/mstksg/advent-of-code-2017/blob/master/reflections.md
[2018]: https://github.com/mstksg/advent-of-code-2018/blob/master/reflections.md
[2019]: https://github.com/mstksg/advent-of-code-2019/blob/master/reflections.md

[Available as an RSS Feed][rss]

[rss]: http://feeds.feedburner.com/jle-advent-of-code-2020

Table of Contents
-----------------

* [Day 1](#day-1)

Day 1
------

<!--
This section is generated and compiled by the build script at ./Build.hs from
the file `./reflections/day01.md`.  If you want to edit this, edit
that file instead!
-->

*[Prompt][d01p]* / *[Code][d01g]* / *[Rendered][d01h]*

[d01p]: https://adventofcode.com/2020/day/1
[d01g]: https://github.com/mstksg/advent-of-code-2020/blob/master/src/AOC/Challenge/Day01.hs
[d01h]: https://mstksg.github.io/advent-of-code-2020/src/AOC.Challenge.Day01.html

Day 1 is usually a fun one to do in Haskell! :D  Today I used one of my more
favorite little list utility functions, `select`:

```haskell
select :: [a] -> [(a,[a])]
select = go []
  where
    go _  [] = []
    go xs (y:ys) = (y,xs++ys) : go (y:xs) ys
```

Not strictly necessary to solve this, but it returns a list of every element in
a list paired with the list *excluding* that element.  (I used it in a [blog
post][sendmoremoney] in the past).

[sendmoremoney]: https://blog.jle.im/entry/unique-sample-drawing-searches-with-list-and-statet.html

```haskell
ghci> select [1,2,3]
[(1,[2,3]),(2,[1,3]),(3,[2,1])]
```

Part 1 then becomes, with the list monad to simulate searches:

```haskell
findPair :: [Int] -> Maybe Int
findPair xs = listToMaybe $ do
    (x, ys) <- select xs
    y       <- ys
    guard $ x + y == 2020
    pure (x*y)
```

And Part 2 is not much more complicated:

```haskell
findTriple :: [Int] -> Maybe Int
findTriple xs = listToMaybe $ do
    (x, ys) <- select xs
    (y, zs) <- select ys
    z       <- zs
    guard $ x + y + z == 2020
    pure (x*y*z)
```

The simpler way would be to just `do x <- xs; y <- xs; z <- xs; ...`, and
either hope that you don't accidentally select a duplicate, or validate that
you didn't draw any duplicates.  But it's always fun to do selecty constrainty
searches when you have the opportunity :D


### Day 1 Benchmarks

```
>> Day 01a
benchmarking...
time                 150.4 μs   (142.9 μs .. 159.9 μs)
                     0.961 R²   (0.925 R² .. 0.992 R²)
mean                 148.0 μs   (138.9 μs .. 175.3 μs)
std dev              51.41 μs   (18.38 μs .. 101.9 μs)
variance introduced by outliers: 98% (severely inflated)

* parsing and formatting times excluded

>> Day 01b
benchmarking...
time                 11.42 ms   (10.81 ms .. 12.10 ms)
                     0.965 R²   (0.930 R² .. 0.988 R²)
mean                 11.28 ms   (10.79 ms .. 11.67 ms)
std dev              1.220 ms   (983.2 μs .. 1.652 ms)
variance introduced by outliers: 56% (severely inflated)

* parsing and formatting times excluded
```

